package validator

import (
	"crypto/tls"
	"crypto/x509"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"watchdog_exporter/config"

	"github.com/stretchr/testify/assert"
)

// testTLSChecker lets us inject a tls.Config with custom RootCAs + delegates Inspect/Check to DefaultTLSChecker.
type testTLSChecker struct {
	rootCAs  *x509.CertPool
	serverSN string
	delegate *DefaultTLSChecker
}

func (t *testTLSChecker) TLSClientConfigWithSNI(serverName string) *tls.Config {
	if t.serverSN == "" {
		t.serverSN = serverName
	}
	return &tls.Config{
		RootCAs:    t.rootCAs,
		ServerName: t.serverSN,
		MinVersion: tls.VersionTLS12,
	}
}

func (t *testTLSChecker) CheckHandshakeError(err error) (string, bool) {
	return t.delegate.CheckHandshakeError(err)
}

func (t *testTLSChecker) Inspect(resp *http.Response) CertsReport {
	return t.delegate.Inspect(resp)
}

func TestValidate_TLS_InvalidChain(t *testing.T) {
	// NewTLSServer uses a self-signed cert not trusted by default RootCAs.
	srv := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		_, _ = io.WriteString(w, "ok")
	}))
	defer srv.Close()

	req := config.EndpointRequest{
		URL:     srv.URL,
		Timeout: 2 * time.Second,
		Method:  http.MethodGet,
		Headers: map[string]string{},
	}
	route := config.Route{}

	// DefaultTLSChecker does not add RootCAs, so handshake should fail and be classified.
	tc := NewDefaultTLSChecker(false)
	hc := NewDefaultHTTPResponseChecker(false)
	v := NewWatchDogValidator(tc, hc, false)

	status, duration, rep, err := v.Validate("ep", req, "rt", route, &config.EndpointValidation{StatusCode: http.StatusOK}, true)
	assert.Error(t, err)
	assert.Equal(t, "invalid-tls-chain", status)
	assert.GreaterOrEqual(t, duration, 0.0)
	assert.Nil(t, rep)
}

func TestValidate_TLS_ChainValid_And_CertList(t *testing.T) {
	// HTTPS server with self-signed cert; we'll trust it via custom RootCAs in testTLSChecker.
	srv := httptest.NewTLSServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Minimal body; status must match expected for "valid".
		w.WriteHeader(http.StatusOK)
		_, _ = io.WriteString(w, "hello tls")
	}))
	defer srv.Close()

	// Build RootCAs from server cert.
	certDER := srv.TLS.Certificates[0].Certificate[0]
	cert, err := x509.ParseCertificate(certDER)
	assert.NoError(t, err)

	pool := x509.NewCertPool()
	pool.AddCert(cert)

	// Inject a TLS checker that trusts the server.
	tc := &testTLSChecker{
		rootCAs:  pool,
		delegate: NewDefaultTLSChecker(false),
	}
	hc := NewDefaultHTTPResponseChecker(false)
	v := NewWatchDogValidator(tc, hc, false)

	req := config.EndpointRequest{
		URL:     srv.URL, // points to 127.0.0.1:port with a cert whose CN/SAN matches server name used by the client
		Timeout: 2 * time.Second,
		Method:  http.MethodGet,
		Headers: map[string]string{},
	}
	route := config.Route{}

	// Run validate with TLS check enabled so Inspect() is used.
	status, duration, rep, err := v.Validate("ep", req, "rt", route, &config.EndpointValidation{StatusCode: http.StatusOK}, true)
	assert.NoError(t, err)
	assert.Equal(t, "valid", status)
	assert.GreaterOrEqual(t, duration, 0.0)
	assert.NotNil(t, rep)

	// Check TLS report: should have HadTLS, ChainValid true, and at least leaf cert info.
	assert.True(t, rep.HadTLS, "expected TLS")
	assert.True(t, rep.ChainValid, "expected validated chain")
	if assert.GreaterOrEqual(t, len(rep.Certificates), 1, "expected at least leaf certificate") {
		leaf := rep.Certificates[0]
		// We don't assert exact days, but it should be > 0 for autogenerated test certs.
		assert.Greater(t, leaf.DaysLeft, 0.0)
		// Basic sanity on fields:
		assert.Equal(t, 0, leaf.Position)
		if leaf.CommonName == "" && leaf.SubjectAltNames == nil && len(leaf.SubjectAltNames) == 0 {
			t.Fatalf("expected non-empty CommonName or SubjectAltNames")
		}
		assert.NotZero(t, leaf.NotAfter.Unix())
	}
}
